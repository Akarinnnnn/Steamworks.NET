// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2021 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class Version {
		public const string SteamworksNETVersion = "15.0.0";
		public const string SteamworksSDKVersion = "1.50";
		public const string SteamAPIDLLVersion = "06.06.99.59";
		public const int SteamAPIDLLSize = 239392;
		public const int SteamAPI64DLLSize = 264480;
	}

	public static class SteamAPI {
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	Steam API setup & shutdown
		//
		//	These functions manage loading, initializing and shutdown of the steamclient.dll
		//
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//


		// SteamAPI_Init must be called before using any other API functions. If it fails, an
		// error message will be output to the debugger (or stderr) with further information.
		public static bool Init() {
			InteropHelp.TestIfPlatformSupported();

			bool ret = NativeMethods.SteamAPI_Init();

			// Steamworks.NET specific: We initialize the SteamAPI Context like this for now, but we need to do it
			// every time that Unity reloads binaries, so we also check if the pointers are available and initialized
			// before each call to any interface functions. That is in InteropHelp.cs
			if (ret)
			{
				ret = CSteamAPIContext.Init();
			}

			if (ret)
				CallbackDispatcher.Initialize();

			return ret;
		}

		// SteamAPI_Shutdown should be called during process shutdown if possible.
		public static void Shutdown() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamAPI_Shutdown();
			CSteamAPIContext.Clear();
			CallbackDispatcher.Shutdown();
		}

		// SteamAPI_RestartAppIfNecessary ensures that your executable was launched through Steam.
		//
		// Returns true if the current process should terminate. Steam is now re-launching your application.
		//
		// Returns false if no action needs to be taken. This means that your executable was started through
		// the Steam client, or a steam_appid.txt file is present in your game's directory (for development).
		// Your current process should continue if false is returned.
		//
		// NOTE: If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary
		// since the DRM wrapper will ensure that your application was launched properly through Steam.
		public static bool RestartAppIfNecessary(AppId_t unOwnAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamAPI_RestartAppIfNecessary(unOwnAppID);
		}

		// Many Steam API functions allocate a small amount of thread-local memory for parameter storage.
		// SteamAPI_ReleaseCurrentThreadMemory() will free API memory associated with the calling thread.
		// This function is also called automatically by SteamAPI_RunCallbacks(), so a single-threaded
		// program never needs to explicitly call this function.
		public static void ReleaseCurrentThreadMemory() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamAPI_ReleaseCurrentThreadMemory();
		}

		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	steam callback and call-result helpers
		//
		//	The following macros and classes are used to register your application for
		//	callbacks and call-results, which are delivered in a predictable manner.
		//
		//	STEAM_CALLBACK macros are meant for use inside of a C++ class definition.
		//	They map a Steam notification callback directly to a class member function
		//	which is automatically prototyped as "void func( callback_type *pParam )".
		//
		//	CCallResult is used with specific Steam APIs that return "result handles".
		//	The handle can be passed to a CCallResult object's Set function, along with
		//	an object pointer and member-function pointer. The member function will
		//	be executed once the results of the Steam API call are available.
		//
		//	CCallback and CCallbackManual classes can be used instead of STEAM_CALLBACK
		//	macros if you require finer control over registration and unregistration.
		//
		//	Callbacks and call-results are queued automatically and are only
		//	delivered/executed when your application calls SteamAPI_RunCallbacks().
		//
		//	Note that there is an alternative, lower level callback dispatch mechanism.
		//	See SteamAPI_ManualDispatch_Init
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//

		// Dispatch all queued Steamworks callbacks.
		//
		// This is safe to call from multiple threads simultaneously,
		// but if you choose to do this, callback code could be executed on any thread.
		// One alternative is to call SteamAPI_RunCallbacks from the main thread only,
		// and call SteamAPI_ReleaseCurrentThreadMemory regularly on other threads.
		public static void RunCallbacks() {
			CallbackDispatcher.RunFrame(false);
		}

		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	steamclient.dll private wrapper functions
		//
		//	The following functions are part of abstracting API access to the steamclient.dll, but should only be used in very specific cases
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//

		// SteamAPI_IsSteamRunning() returns true if Steam is currently running
		public static bool IsSteamRunning() {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamAPI_IsSteamRunning();
		}

		// returns the pipe we are communicating to Steam with
		public static HSteamPipe GetHSteamPipe() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamPipe)NativeMethods.SteamAPI_GetHSteamPipe();
		}

		public static HSteamUser GetHSteamUser() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamUser)NativeMethods.SteamAPI_GetHSteamUser();
		}
	}

	public static class GameServer {
		// Initialize ISteamGameServer interface object, and set server properties which may not be changed.
		//
		// After calling this function, you should set any additional server parameters, and then
		// call ISteamGameServer::LogOnAnonymous() or ISteamGameServer::LogOn()
		//
		// - usSteamPort is the local port used to communicate with the steam servers.
		// - usGamePort is the port that clients will connect to for gameplay.
		// - usQueryPort is the port that will manage server browser related duties and info
		//		pings from clients.  If you pass MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE for usQueryPort, then it
		//		will use "GameSocketShare" mode, which means that the game is responsible for sending and receiving
		//		UDP packets for the master  server updater. See references to GameSocketShare in isteamgameserver.h.
		// - The version string is usually in the form x.x.x.x, and is used by the master server to detect when the
		//		server is out of date.  (Only servers with the latest version will be listed.)
		public static bool Init(uint unIP, ushort usSteamPort, ushort usGamePort, ushort usQueryPort, EServerMode eServerMode, string pchVersionString) {
			InteropHelp.TestIfPlatformSupported();

			bool ret;
			using (var pchVersionString2 = new InteropHelp.UTF8StringHandle(pchVersionString)) {
				ret = NativeMethods.SteamGameServer_Init(unIP, usSteamPort, usGamePort, usQueryPort, eServerMode, pchVersionString2);
			}

			// Steamworks.NET specific: We initialize the SteamAPI Context like this for now, but we need to do it
			// every time that Unity reloads binaries, so we also check if the pointers are available and initialized
			// before each call to any interface functions. That is in InteropHelp.cs
			if (ret) {
				ret = CSteamGameServerAPIContext.Init();
			}

			if (ret)
				CallbackDispatcher.Initialize();

			return ret;
		}

		public static void Shutdown() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamGameServer_Shutdown();
			CSteamGameServerAPIContext.Clear();
			CallbackDispatcher.Shutdown();
		}

		public static void RunCallbacks() {
			CallbackDispatcher.RunFrame(true);
		}

		// Most Steam API functions allocate some amount of thread-local memory for
		// parameter storage. Calling SteamGameServer_ReleaseCurrentThreadMemory()
		// will free all API-related memory associated with the calling thread.
		// This memory is released automatically by SteamGameServer_RunCallbacks(),
		// so single-threaded servers do not need to explicitly call this function.
		public static void ReleaseCurrentThreadMemory() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamGameServer_ReleaseCurrentThreadMemory();
		}

		public static bool BSecure() {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamGameServer_BSecure();
		}

		public static CSteamID GetSteamID() {
			InteropHelp.TestIfPlatformSupported();
			return (CSteamID)NativeMethods.SteamGameServer_GetSteamID();
		}

		public static HSteamPipe GetHSteamPipe() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamPipe)NativeMethods.SteamGameServer_GetHSteamPipe();
		}

		public static HSteamUser GetHSteamUser() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamUser)NativeMethods.SteamGameServer_GetHSteamUser();
		}
	}

	public static class SteamEncryptedAppTicket {
		public static bool BDecryptTicket(byte[] rgubTicketEncrypted, uint cubTicketEncrypted, byte[] rgubTicketDecrypted, ref uint pcubTicketDecrypted, byte[] rgubKey, int cubKey) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BDecryptTicket(rgubTicketEncrypted, cubTicketEncrypted, rgubTicketDecrypted, ref pcubTicketDecrypted, rgubKey, cubKey);
		}

		public static bool BIsTicketForApp(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, AppId_t nAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BIsTicketForApp(rgubTicketDecrypted, cubTicketDecrypted, nAppID);
		}

		public static uint GetTicketIssueTime(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_GetTicketIssueTime(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static void GetTicketSteamID(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, out CSteamID psteamID) {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamEncryptedAppTicket_GetTicketSteamID(rgubTicketDecrypted, cubTicketDecrypted, out psteamID);
		}

		public static uint GetTicketAppID(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_GetTicketAppID(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static bool BUserOwnsAppInTicket(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, AppId_t nAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BUserOwnsAppInTicket(rgubTicketDecrypted, cubTicketDecrypted, nAppID);
		}

		public static bool BUserIsVacBanned(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BUserIsVacBanned(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static byte[] GetUserVariableData(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, out uint pcubUserData) {
			InteropHelp.TestIfPlatformSupported();
			IntPtr punSecretData = NativeMethods.SteamEncryptedAppTicket_GetUserVariableData(rgubTicketDecrypted, cubTicketDecrypted, out pcubUserData);
			byte[] ret = new byte[pcubUserData];
			System.Runtime.InteropServices.Marshal.Copy(punSecretData, ret, 0, (int)pcubUserData);
			return ret;
		}

		public static bool BIsTicketSigned(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, byte[] pubRSAKey, uint cubRSAKey) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BIsTicketSigned(rgubTicketDecrypted, cubTicketDecrypted, pubRSAKey, cubRSAKey);
		}
	}

	internal struct CallbackCounterAndContext
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr OnInterfaceFound(ref IntPtr native_interface);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		public OnInterfaceFound Callback;
		public System.UIntPtr Counter;// size_t
		public IntPtr Pointer;
	}

	internal static class CSteamAPIContext {

		[DllImport(NativeMethods.NativeLibraryName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamInternal_FindOrCreateUserInterface", ExactSpelling = true)]
		private extern static IntPtr SteamInternal_FindOrCreateUserInterface(HSteamUser user, InteropHelp.UTF8StringHandle version);

		[DllImport(NativeMethods.NativeLibraryName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamInternal_ContextInit", ExactSpelling = true)]
		private extern static ref IntPtr SteamInternal_ContextInit(ref CallbackCounterAndContext contextInitData);

		// 27 Interfaces found in CSteamAPIContext class.
		private static CallbackCounterAndContext[] cbcontexts = new CallbackCounterAndContext[28] {
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMCLIENT_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUSER_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMFRIENDS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUTILS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMMATCHMAKING_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUSERSTATS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMAPPS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKING_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMREMOTESTORAGE_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMSCREENSHOTS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMGAMESEARCH_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMHTTP_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMCONTROLLER_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUGC_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMAPPLIST_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMMUSIC_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMMUSICREMOTE_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMHTMLSURFACE_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMINVENTORY_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMVIDEO_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMPARENTALSETTINGS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMINPUT_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMPARTIES_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMREMOTEPLAY_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGMESSAGES_VERSION);
				ref_interface = SteamInternal_FindOrCreateUserInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
	};


		internal static void Clear() {
			return;
		}

		internal static bool Init() {
			if (SteamAPI.GetHSteamPipe().m_HSteamPipe == 0)
				return false;
			return true;
		}

		internal static IntPtr GetSteamClient() { return SteamInternal_ContextInit(ref cbcontexts[0]); }
		internal static IntPtr GetSteamUser() { return SteamInternal_ContextInit(ref cbcontexts[1]); }
		internal static IntPtr GetSteamFriends() { return SteamInternal_ContextInit(ref cbcontexts[2]); }
		internal static IntPtr GetSteamUtils() { return SteamInternal_ContextInit(ref cbcontexts[3]); }
		internal static IntPtr GetSteamMatchmaking() { return SteamInternal_ContextInit(ref cbcontexts[4]); }
		internal static IntPtr GetSteamUserStats() { return SteamInternal_ContextInit(ref cbcontexts[5]); }
		internal static IntPtr GetSteamApps() { return SteamInternal_ContextInit(ref cbcontexts[6]); }
		internal static IntPtr GetSteamMatchmakingServers() { return SteamInternal_ContextInit(ref cbcontexts[7]); }
		internal static IntPtr GetSteamNetworking() { return SteamInternal_ContextInit(ref cbcontexts[8]); }
		internal static IntPtr GetSteamRemoteStorage() { return SteamInternal_ContextInit(ref cbcontexts[9]); }
		internal static IntPtr GetSteamScreenshots() { return SteamInternal_ContextInit(ref cbcontexts[10]); }
		internal static IntPtr GetSteamGameSearch() { return SteamInternal_ContextInit(ref cbcontexts[11]); }
		internal static IntPtr GetSteamHTTP() { return SteamInternal_ContextInit(ref cbcontexts[12]); }
		internal static IntPtr GetSteamController() { return SteamInternal_ContextInit(ref cbcontexts[13]); }
		internal static IntPtr GetSteamUGC() { return SteamInternal_ContextInit(ref cbcontexts[14]); }
		internal static IntPtr GetSteamAppList() { return SteamInternal_ContextInit(ref cbcontexts[15]); }
		internal static IntPtr GetSteamMusic() { return SteamInternal_ContextInit(ref cbcontexts[16]); }
		internal static IntPtr GetSteamMusicRemote() { return SteamInternal_ContextInit(ref cbcontexts[17]); }
		internal static IntPtr GetSteamHTMLSurface() { return SteamInternal_ContextInit(ref cbcontexts[18]); }
		internal static IntPtr GetSteamInventory() { return SteamInternal_ContextInit(ref cbcontexts[19]); }
		internal static IntPtr GetSteamVideo() { return SteamInternal_ContextInit(ref cbcontexts[20]); }
		internal static IntPtr GetSteamParentalSettings() { return SteamInternal_ContextInit(ref cbcontexts[21]); }
		internal static IntPtr GetSteamInput() { return SteamInternal_ContextInit(ref cbcontexts[22]); }
		internal static IntPtr GetSteamParties() { return SteamInternal_ContextInit(ref cbcontexts[23]); }
		internal static IntPtr GetSteamRemotePlay() { return SteamInternal_ContextInit(ref cbcontexts[24]); }
		internal static IntPtr GetSteamNetworkingUtils() { return SteamInternal_ContextInit(ref cbcontexts[25]); }
		internal static IntPtr GetSteamNetworkingSockets() { return SteamInternal_ContextInit(ref cbcontexts[26]); }
		internal static IntPtr GetSteamNetworkingMessages() { return SteamInternal_ContextInit(ref cbcontexts[27]); }
	}

	internal static class CSteamGameServerAPIContext {

		[DllImport(NativeMethods.NativeLibraryName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamInternal_ContextInit", ExactSpelling = true)]
		private extern static ref IntPtr SteamInternal_ContextInit(ref CallbackCounterAndContext contextInitData);

		[DllImport(NativeMethods.NativeLibraryName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamInternal_FindOrCreateGameServerInterface", ExactSpelling = true)]
		private extern static IntPtr SteamInternal_FindOrCreateGameServerInterface(HSteamUser user, InteropHelp.UTF8StringHandle version);

		internal static void Clear() { }
		internal static bool Init() {
			HSteamPipe hSteamPipe = GameServer.GetHSteamPipe();
			if (hSteamPipe.m_HSteamPipe ==0)
				return false;
			else
				return true;
		}

		private static CallbackCounterAndContext[] cbcontexts = new CallbackCounterAndContext[12]
		{
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMCLIENT_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMGAMESERVER_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUTILS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKING_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMGAMESERVERSTATS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMHTTP_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMINVENTORY_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMUGC_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMAPPS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
			new CallbackCounterAndContext { Callback = (ref IntPtr ref_interface) => {
				using var interface_version = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGMESSAGES_VERSION);
				ref_interface = SteamInternal_FindOrCreateGameServerInterface(SteamAPI.GetHSteamUser(), interface_version);
				return ref_interface;
			}},
		};

		internal static IntPtr GetSteamClient() { return SteamInternal_ContextInit(ref cbcontexts[0]); }
		internal static IntPtr GetSteamGameServer() { return SteamInternal_ContextInit(ref cbcontexts[1]); }
		internal static IntPtr GetSteamUtils() { return SteamInternal_ContextInit(ref cbcontexts[2]); }
		internal static IntPtr GetSteamNetworking() { return SteamInternal_ContextInit(ref cbcontexts[3]); }
		internal static IntPtr GetSteamGameServerStats() { return SteamInternal_ContextInit(ref cbcontexts[4]); }
		internal static IntPtr GetSteamHTTP() { return SteamInternal_ContextInit(ref cbcontexts[5]); }
		internal static IntPtr GetSteamInventory() { return SteamInternal_ContextInit(ref cbcontexts[6]); }
		internal static IntPtr GetSteamUGC() { return SteamInternal_ContextInit(ref cbcontexts[7]); }
		internal static IntPtr GetSteamApps() { return SteamInternal_ContextInit(ref cbcontexts[8]); }
		internal static IntPtr GetSteamNetworkingUtils() { return SteamInternal_ContextInit(ref cbcontexts[9]); }
		internal static IntPtr GetSteamNetworkingSockets() { return SteamInternal_ContextInit(ref cbcontexts[10]); }
		internal static IntPtr GetSteamNetworkingMessages() { return SteamInternal_ContextInit(ref cbcontexts[11]); }
	}
}

#endif // !DISABLESTEAMWORKS
